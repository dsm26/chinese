let flashcards = [];
let currentIndex = 0;
let seenIndices = []; // Tracks the order of cards shown

function showCard() {
  if (flashcards.length === 0) return;

  const card = flashcards[currentIndex];
  const showFirst = document.getElementById("showFirstSelect").value;
  const showAnswer = document.getElementById("showAnswerToggle").checked;
  const showPinyin = document.getElementById("showPinyinToggle").checked;

  let question = "", answer = "", pinyin = "";

  if (showFirst === "english") {
    question = card.english;
    answer = card.chinese;
    pinyin = card.pinyin;
  } else {
    question = card.chinese;
    pinyin = card.pinyin;
    answer = card.english;
  }

  document.getElementById("question").textContent = question;
  document.getElementById("answer").textContent = showAnswer ? answer : "";
  document.getElementById("pinyin").textContent =
    (showPinyin && (showFirst === "chinese" || showAnswer)) ? pinyin : "";
}

// Next button logic
function nextCard() {
  if (flashcards.length === 0) return;

  const randomMode = document.getElementById("randomToggle").checked;

  if (randomMode) {
    // Pick an unseen word first
    const unseen = flashcards.map((_, i) => i).filter(i => !seenIndices.includes(i));
    if (unseen.length === 0) {
      // All words seen, reset the unseen pool
      seenIndices = [];
      nextCard(); // call recursively to pick from full set
      return;
    }
    const randIndex = unseen[Math.floor(Math.random() * unseen.length)];
    currentIndex = randIndex;
    seenIndices.push(currentIndex);
  } else {
    // Sequential mode
    currentIndex = (currentIndex + 1) % flashcards.length;
    if (!seenIndices.includes(currentIndex)) seenIndices.push(currentIndex);
  }

  showCard();
}

// Previous button logic (always sequential in seen order)
function prevCard() {
  if (seenIndices.length <= 1) return; // no previous
  // Remove current index
  seenIndices.pop();
  // Go back to the last seen
  currentIndex = seenIndices[seenIndices.length - 1];
  showCard();
}
